import {
  BadRequestException,
  Body,
  Controller,
  Get,
  Param,
  Post,
  Put,
  Query,
  UseGuards,
} from '@nestjs/common';
import { ExploitService } from './exploit.service';
import {
  CreateExploitRequestDto,
  SearchExploitsResponseDto,
  ExploitResponseDto,
  SearchExploitsQueryDto,
} from './dto';
import { InjectQueue } from '@nestjs/bull';
import { Queue } from 'bull';
import { RolesGuard } from '../user/guard/roles.guard';
import { Roles } from '../user/guard/roles.decorator';
import { Role } from '@prisma/client';
import {
  ApiConflictResponse,
  ApiCreatedResponse,
  ApiHeader,
  ApiNotFoundResponse,
  ApiOkResponse,
  ApiOperation,
  ApiTags,
} from '@nestjs/swagger';
import { JwtAuthGuard } from '../user/guard/jwt-auth.guard';
import { ContractService } from '../contract/contract.service';

@ApiTags('exploit')
@Controller('exploit')
export class ExploitController {
  constructor(
    @InjectQueue('exploitNotify')
    private readonly exploitNotifyQueue: Queue,
    private readonly exploitService: ExploitService,
    private readonly contractService: ContractService
  ) {}

  @Get('id/:exploitId')
  @ApiOperation({ summary: 'Gets exploit by exploitId.' })
  @ApiOkResponse({
    description: 'Returns the exploit by exploitId',
    type: ExploitResponseDto,
  })
  @ApiNotFoundResponse({
    description: 'The exploit with the given exploitId does not exist.',
  })
  public async getExploitById(
    @Param('exploitId') exploitId: string
  ): Promise<ExploitResponseDto> {
    return this.exploitService.getExploit(exploitId);
  }

  @Get('search')
  @ApiOperation({ summary: 'Searches for the exploit by the name query.' })
  @ApiOkResponse({
    description: 'Returns exploits matching the search query.',
    type: SearchExploitsResponseDto,
  })
  public async searchExploitByName(
    @Query() queryInfo: SearchExploitsQueryDto
  ): Promise<SearchExploitsResponseDto> {
    const searchDto = {
      name: queryInfo.name ? queryInfo.name : '',
      pageNo: parseInt(queryInfo.pageNo),
    };
    if (searchDto.pageNo < 1) {
      throw new BadRequestException();
    }
    const c = {
      data: await this.exploitService.searchExploitByName(searchDto),
    };
    return c;
  }

  @Post()
  @ApiOperation({ summary: 'Creates a new exploit.' })
  @ApiCreatedResponse({
    description:
      'Created a new exploit on the database, and has returned the exploit that has just been added',
    type: ExploitResponseDto,
  })
  @ApiConflictResponse({
    description: 'There already exists an exploit with the same name.',
  })
  public async createExploit(
    @Body() createExploitRequestDto: CreateExploitRequestDto
  ): Promise<ExploitResponseDto> {
    if (
      !(await this.contractService.isValidGithubContract({
        author: createExploitRequestDto.targetAuthor,
        path: createExploitRequestDto.targetPath,
        repo: createExploitRequestDto.targetRepo,
        ref: createExploitRequestDto.targetRef,
      }))
    ) {
      throw new BadRequestException('Invalid GitHub Contract.');
    }
    return this.exploitService.createExploit(createExploitRequestDto);
  }

  @Put('verify/:exploitId')
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles(Role.ADMIN)
  @ApiHeader({
    name: 'Authorization',
    description:
      'The JWT of current login user that contains the username (email).',
    required: true,
  })
  @ApiOperation({
    summary:
      'Verifies the exploit by their exploitId, and creates a job to notify/pause managers of the smart contracts that have this exploit.',
  })
  @ApiCreatedResponse({ description: 'Added to queue for verification.' })
  public async verifyexploit(@Param('exploitId') exploitId: string) {
    await this.exploitService.verifyExploit(exploitId);
    await this.exploitNotifyQueue.add({ exploitId: exploitId });
  }
}
